{
 "userName": "Solhvemjsun",
 "date": "2025-06-14T16:51:51.100Z",
 "numShaders": 1,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "WfyXRw",
    "date": "1749914837",
    "viewed": 1,
    "name": "Fork GR BH with Solhvemjsun",
    "description": "鼠标拖动以改变视角,w和s改变距离\n原作者开发记录：https://zhuanlan.zhihu.com/p/20536269771\n",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "volume",
     "blackhole",
     "gravity"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//渲染部分在BufferA，BufferBCD和image来自sonicether的作品Gargantua With HDR Bloom\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    \n    color += GetBloom(uv) * 0.08;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XdfGRn",
       "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// #version 450\n\n// layout(location = 0) out vec4 FragColor;\n\n// layout(set = 0, binding = 0) uniform UniformBuffer\n// {\n//     float Fov;\n//     float TimeRate = 30.;  // 本部分在实际使用时又uniform输入，此外所有iTime*TimeRate应替换为游戏内时间。\n//     float MBlackHole = 1.49e7;                                                                          // 单位是太阳质量 本部分在实际使用时uniform输入\n//     float a0         = 0.0;                                                                             // 无量纲自旋系数 本部分在实际使用时uniform输入\n//     float Rs         = 2. * MBlackHole * kGravityConstant / kSpeedOfLight / kSpeedOfLight * kSolarMass;  // 单位是米 本部分在实际使用时uniform输入\n//     float z1       = 1. + pow(1. - a0 * a0, 0.333333333333333) * (pow(1. + a0 * a0, 0.333333333333333) + pow(1. - a0, 0.333333333333333));  // 辅助变量      本部分在实际使用时uniform输入\n//     float RmsRatio = (3. + sqrt(3. * a0 * a0 + z1 * z1) - sqrt((3. - z1) * (3. + z1 + 2. * sqrt(3. * a0 * a0 + z1 * z1)))) / 2.;            // 赤道顺行最内稳定圆轨与Rs之比    本部分在实际使用时uniform输入\n//     float AccEff   = sqrt(1. - 1. / RmsRatio);                                                                                              // 吸积放能效率,以落到Rms为准 本部分在实际使用时uniform输入\n//     float mu      = 1.;                                                                            // 吸积物的比荷的倒数,氕为1 本部分在实际使用时uniform输入\n//     float dmdtEdd = 6.327 * mu / kSpeedOfLight / kSpeedOfLight * MBlackHole * kSolarMass / AccEff;  // 爱丁顿吸积率 本部分在实际使用时uniform输入\n//     float dmdt = (2e-6) * dmdtEdd;  // 吸积率 本部分在实际使用时uniform输入\n//     float diskA = 3. * kGravityConstant * kSolarMass / Rs / Rs / Rs * MBlackHole * dmdt / (8. * kPi * kSigma);  // 吸积盘温度系数 本部分在实际使用时uniform输入\n//     // 计算峰值温度的四次方,用于自适应亮度。峰值温度出现在49InterRadius/36处\n//     float QuadraticedPeakTemperature = diskA * 0.05665278;  //                                                                                          本部分在实际使用时uniform输入\n//     float InterRadius  = 0.7 * RmsRatio * Rs;  // 盘内缘,正常情况下等于最内稳定圆轨\n//     float OuterRadius = 12. * Rs;             // 盘外缘 本部分在实际使用时uniform输入\n// };\n\nconst float kPi              = 3.141592653589;\nconst float kGravityConstant = 6.673e-11;\nconst float kSpeedOfLight    = 299792458.0;\nconst float kSigma           = 5.670373e-8;\nconst float kLightYear       = 9460730472580800.0;\nconst float kSolarMass       = 1.9884e30;\n\nfloat RandomStep(vec2 Input, float Seed)\n{\n    return fract(sin(dot(Input + fract(11.4514 * sin(Seed)), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat CubicInterpolate(float x)\n{\n    return 3.0 * x * x - 2.0 * x * x * x;\n}\n\nfloat PerlinNoise(vec3 Position)\n{\n    vec3 PosInt   = floor(Position);\n    vec3 PosFloat = fract(Position);\n\n    float v000 = 2.0 * fract(sin(dot(vec3(PosInt.x,       PosInt.y,       PosInt.z),       vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n    float v100 = 2.0 * fract(sin(dot(vec3(PosInt.x + 1.0, PosInt.y,       PosInt.z),       vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n    float v010 = 2.0 * fract(sin(dot(vec3(PosInt.x,       PosInt.y + 1.0, PosInt.z),       vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n    float v110 = 2.0 * fract(sin(dot(vec3(PosInt.x + 1.0, PosInt.y + 1.0, PosInt.z),       vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n    float v001 = 2.0 * fract(sin(dot(vec3(PosInt.x,       PosInt.y,       PosInt.z + 1.0), vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n    float v101 = 2.0 * fract(sin(dot(vec3(PosInt.x + 1.0, PosInt.y,       PosInt.z + 1.0), vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n    float v011 = 2.0 * fract(sin(dot(vec3(PosInt.x,       PosInt.y + 1.0, PosInt.z + 1.0), vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n    float v111 = 2.0 * fract(sin(dot(vec3(PosInt.x + 1.0, PosInt.y + 1.0, PosInt.z + 1.0), vec3(12.9898, 78.233, 213.765))) * 43758.5453) - 1.0;\n\n    float v00 = v001 * CubicInterpolate(PosFloat.z) + v000 * CubicInterpolate(1.0 - PosFloat.z);\n    float v10 = v101 * CubicInterpolate(PosFloat.z) + v100 * CubicInterpolate(1.0 - PosFloat.z);\n    float v01 = v011 * CubicInterpolate(PosFloat.z) + v010 * CubicInterpolate(1.0 - PosFloat.z);\n    float v11 = v111 * CubicInterpolate(PosFloat.z) + v110 * CubicInterpolate(1.0 - PosFloat.z);\n    float v0  = v01  * CubicInterpolate(PosFloat.y) + v00  * CubicInterpolate(1.0 - PosFloat.y);\n    float v1  = v11  * CubicInterpolate(PosFloat.y) + v10  * CubicInterpolate(1.0 - PosFloat.y);\n\n    return v1 * CubicInterpolate(PosFloat.x) + v0 * CubicInterpolate(1.0 - PosFloat.x);\n}\n\nfloat SoftSaturate(float x)\n{\n    return 1.0 - 1.0 / (max(x, 0.0) + 1.0);\n}\n\nfloat GenerateAccretionDiskNoise(vec3 Position, int NoiseStartLevel, int NoiseEndLevel, float ContrastLevel)\n{\n    float NoiseAccumulator = 10.0;\n    float NoiseFrequency   = 1.0;\n    \n    for (int Level = NoiseStartLevel; Level < NoiseEndLevel; ++Level)\n    {\n        NoiseFrequency = pow(3.0, float(Level));\n        vec3 ScaledPosition = vec3(NoiseFrequency * Position.x, NoiseFrequency * Position.y, NoiseFrequency * Position.z);\n\n        NoiseAccumulator *= (1.0 + 0.1 * PerlinNoise(ScaledPosition));\n    }\n    \n    return log(1.0 + pow(0.1 * NoiseAccumulator, ContrastLevel));\n}\n\nfloat Vec2ToTheta(vec2 v1, vec2 v2)\n{\n    if (dot(v1, v2) > 0.0)\n    {\n        return asin(0.999999 * (v1.x * v2.y - v1.y * v2.x) / length(v1) / length(v2));\n    }\n    else if (dot(v1, v2) < 0.0 && (-v1.x * v2.y + v1.y * v2.x) < 0.0)\n    {\n        return kPi - asin(0.999999 * (v1.x * v2.y - v1.y * v2.x) / length(v1) / length(v2));\n    }\n    else if (dot(v1, v2) < 0.0 && (-v1.x * v2.y + v1.y * v2.x) > 0.0)\n    {\n        return -kPi - asin(0.999999 * (v1.x * v2.y - v1.y * v2.x) / length(v1) / length(v2));\n    }\n}\n\nvec3 KelvinToRgb(float Kelvin)\n{\n    if (Kelvin < 400.01)\n    {\n        return vec3(0.0);\n    }\n\n    float Teff     = (Kelvin - 6500.0) / (6500.0 * Kelvin * 2.2);\n    vec3  RgbColor = vec3(0.0);\n    \n    RgbColor.r = exp(2.05539304e4 * Teff);\n    RgbColor.g = exp(2.63463675e4 * Teff);\n    RgbColor.b = exp(3.30145739e4 * Teff);\n\n    float BrightnessScale = 1.0 / max(max(RgbColor.r, RgbColor.g), RgbColor.b);\n    \n    if (Kelvin < 1000.0)\n    {\n        BrightnessScale *= (Kelvin - 400.0) / 600.0;\n    }\n    \n    RgbColor *= BrightnessScale;\n    return RgbColor;\n}\n\nfloat GetKeplerianAngularVelocity(float Radius, float Rs)\n{\n    return sqrt(kSpeedOfLight / kLightYear * kSpeedOfLight * Rs / kLightYear / ((2.0 * Radius - 3.0 * Rs) * Radius * Radius));\n}\n\nvec3 WorldToBlackHoleSpace(vec4 Position, vec3 BlackHolePos, vec3 DiskNormal,vec3 WorldUp)\n{\n    if (DiskNormal == WorldUp)\n    {\n        DiskNormal += 0.0001 * vec3(1.0, 0.0, 0.0);\n    }\n\n    vec3 BlackHoleSpaceY = normalize(DiskNormal);\n    vec3 BlackHoleSpaceZ = normalize(cross(WorldUp, BlackHoleSpaceY));\n    vec3 BlackHoleSpaceX = normalize(cross(BlackHoleSpaceY, BlackHoleSpaceZ));\n\n    mat4x4 Translate = mat4x4(1.0, 0.0, 0.0, -BlackHolePos.x,\n                              0.0, 1.0, 0.0, -BlackHolePos.y,\n                              0.0, 0.0, 1.0, -BlackHolePos.z,\n                              0.0, 0.0, 0.0, 1.0);\n\n    mat4x4 Rotate = mat4x4(BlackHoleSpaceX.x, BlackHoleSpaceX.y, BlackHoleSpaceX.z, 0.0,\n                           BlackHoleSpaceY.x, BlackHoleSpaceY.y, BlackHoleSpaceY.z, 0.0,\n                           BlackHoleSpaceZ.x, BlackHoleSpaceZ.y, BlackHoleSpaceZ.z, 0.0,\n                           0.0,               0.0,               0.0,               1.0);\n\n    Position = transpose(Translate) * Position;\n    Position = transpose(Rotate)    * Position;\n    return Position.xyz;\n}\n\nvec3 ApplyBlackHoleRotation(vec4 Position, vec3 BlackHolePos, vec3 DiskNormal,vec3 WorldUp)\n{\n    if (DiskNormal == WorldUp)\n    {\n        DiskNormal += 0.0001 * vec3(1.0, 0.0, 0.0);\n    }\n\n    vec3 BlackHoleSpaceY = normalize(DiskNormal);\n    vec3 BlackHoleSpaceZ = normalize(cross(WorldUp, BlackHoleSpaceY));\n    vec3 BlackHoleSpaceX = normalize(cross(BlackHoleSpaceY, BlackHoleSpaceZ));\n\n    mat4x4 Rotate = mat4x4(BlackHoleSpaceX.x, BlackHoleSpaceX.y, BlackHoleSpaceX.z, 0.0,\n                           BlackHoleSpaceY.x, BlackHoleSpaceY.y, BlackHoleSpaceY.z, 0.0,\n                           BlackHoleSpaceZ.x, BlackHoleSpaceZ.y, BlackHoleSpaceZ.z, 0.0,\n                           0.0,               0.0,               0.0,               1.0);\n\n    Position = transpose(Rotate) * Position;\n    return Position.xyz;\n}\n\nvec4 GetCamera(vec4 Position)  // 相机系平移旋转  本部分在实际使用时uniform输入\n{\n    float Theta = 4.0 * kPi * iMouse.x / iResolution.x;\n    float Phi   = 0.999 * kPi * iMouse.y / iResolution.y + 0.0005;\n    float R     = 0.000057;\n\n    if (iFrame < 2)\n    {\n        Theta = 4.0 * kPi * 0.45;\n        Phi   = 0.999 * kPi * 0.55 + 0.0005;\n    }\n    if (texelFetch(iChannel0, ivec2(83, 0), 0).x > 0.)\n    {\n        R = 0.000097;\n    }\n    if (texelFetch(iChannel0, ivec2(87, 0), 0).x > 0.)\n    {\n        R = 0.0000186;\n    }\n    vec3 Rotcen = vec3(0.0, 0.0, 0.0);\n\n    vec3 Campos;\n\n    vec3 reposcam = vec3(R * sin(Phi) * cos(Theta), -R * cos(Phi), -R * sin(Phi) * sin(Theta));\n\n    Campos    = Rotcen + reposcam;\n    vec3 vecy = vec3(0.0, 1.0, 0.0);\n\n    vec3 X = normalize(cross(vecy, reposcam));\n    vec3 Y = normalize(cross(reposcam, X));\n    vec3 Z = normalize(reposcam);\n\n    Position = (transpose(mat4x4(1., 0., 0., -Campos.x, 0., 1., 0., -Campos.y, 0., 0., 1., -Campos.z, 0., 0., 0., 1.)) * Position);\n\n    Position = transpose(mat4x4(X.x, X.y, X.z, 0., Y.x, Y.y, Y.z, 0., Z.x, Z.y, Z.z, 0., 0., 0., 0., 1.)) * Position;\n\n    return Position;\n}\n\nvec4 GetCameraRot(vec4 Position)  // 摄影机系旋转    本部分在实际使用时uniform输入\n{\n    float Theta = 4.0 * kPi * iMouse.x / iResolution.x;\n    float Phi   = 0.999 * kPi * iMouse.y / iResolution.y + 0.0005;\n    float R     = 0.000057;\n\n    if (iFrame < 2)\n    {\n        Theta = 4.0 * kPi * 0.45;\n        Phi   = 0.999 * kPi * 0.55 + 0.0005;\n    }\n    if (texelFetch(iChannel0, ivec2(83, 0), 0).x > 0.)\n    {\n        R = 0.000097;\n    }\n    if (texelFetch(iChannel0, ivec2(87, 0), 0).x > 0.)\n    {\n        R = 0.0000186;\n    }\n    vec3 Rotcen = vec3(0.0, 0.0, 0.0);\n\n    vec3 Campos;\n\n    vec3 reposcam = vec3(R * sin(Phi) * cos(Theta), -R * cos(Phi), -R * sin(Phi) * sin(Theta));\n\n    Campos    = Rotcen + reposcam;\n    vec3 vecy = vec3(0.0, 1.0, 0.0);\n\n    vec3 X = normalize(cross(vecy, reposcam));\n    vec3 Y = normalize(cross(reposcam, X));\n    vec3 Z = normalize(reposcam);\n    \n    Position = transpose(mat4x4(X.x, X.y, X.z, 0., Y.x, Y.y, Y.z, 0., Z.x, Z.y, Z.z, 0., 0., 0., 0., 1.)) * Position;\n    return Position;\n}\n\nvec3 FragUvToDir(vec2 FragUv, float Fov)\n{\n    return normalize(vec3(Fov * (2.0 * FragUv.x - 1.0), Fov * (2.0 * FragUv.y - 1.0) * iResolution.y / iResolution.x, -1.0));\n}\n\nvec2 PosToNdc(vec4 Pos)\n{\n    return vec2(-Pos.x / Pos.z, -Pos.y / Pos.z * iResolution.x / iResolution.y);\n}\n\nvec2 DirToNdc(vec3 Dir)\n{\n    return vec2(-Dir.x / Dir.z, -Dir.y / Dir.z * iResolution.x / iResolution.y);\n}\n\nvec2 DirToFragUv(vec3 Dir)\n{\n    return vec2(0.5 - 0.5 * Dir.x / Dir.z, 0.5 - 0.5 * Dir.y / Dir.z * iResolution.x / iResolution.y);\n}\n\nvec2 PosToFragUv(vec4 Pos)\n{\n    return vec2(0.5 - 0.5 * Pos.x / Pos.z, 0.5 - 0.5 * Pos.y / Pos.z * iResolution.x / iResolution.y);\n}\n\nfloat Shape(float x, float Alpha, float Beta)\n{\n    float k = pow(Alpha + Beta, Alpha + Beta) / (pow(Alpha, Alpha) * pow(Beta, Beta));\n    return k * pow(x, Alpha) * pow(1.0 - x, Beta);\n}\n\nvec4 DiskColor(vec4 BaseColor, float TimeRate, float StepLength, vec3 RayPos, vec3 LastRayPos,\n               vec3 RayDir, vec3 LastRayDir, vec3 WorldUp, vec3 BlackHolePos, vec3 DiskNormal,\n               float Rs, float InterRadius, float OuterRadius, float DiskTemperatureArgument,\n               float QuadraticedPeakTemperature, float ShiftMax)\n{\n    vec3 CameraPos = WorldToBlackHoleSpace(vec4(0.0, 0.0, 0.0, 1.0), BlackHolePos, DiskNormal, WorldUp);\n    vec3 PosOnDisk = WorldToBlackHoleSpace(vec4(RayPos, 1.0),        BlackHolePos, DiskNormal, WorldUp);\n    vec3 DirOnDisk = ApplyBlackHoleRotation(vec4(RayDir, 1.0),       BlackHolePos, DiskNormal, WorldUp);\n\n    float PosR = length(PosOnDisk.zx);\n    float PosY = PosOnDisk.y;\n\n    vec4 Color = vec4(0.0);\n    if (abs(PosY) < 0.5 * Rs && PosR < OuterRadius && PosR > InterRadius)\n    {\n        float EffectiveRadius = 1.0 - ((PosR - InterRadius) / (OuterRadius - InterRadius) * 0.5);\n        if ((OuterRadius - InterRadius) > 9.0 * Rs)\n        {\n            if (PosR < 5.0 * Rs + InterRadius)\n            {\n                EffectiveRadius = 1.0 - ((PosR - InterRadius) / (9.0 * Rs) * 0.5);\n            }\n            else\n            {\n                EffectiveRadius = 1.0 - (0.5 / 0.9 * 0.5 + ((PosR - InterRadius) / (OuterRadius - InterRadius) -\n                                  5.0 * Rs / (OuterRadius - InterRadius)) / (1.0 - 5.0 * Rs / (OuterRadius - InterRadius)) * 0.5);\n            }\n        }\n\n        if ((abs(PosY) < 0.5 * Rs * Shape(EffectiveRadius, 4.0, 0.9)) || (PosY < 0.5 * Rs * (1.0 - 5.0 * pow(2.0 * (1.0 - EffectiveRadius), 2.0))))\n        {\n            float AngularVelocity  = GetKeplerianAngularVelocity(PosR, Rs);\n            float HalfPiTimeInside = kPi / GetKeplerianAngularVelocity(3.0 * Rs, Rs);\n\n            float SpiralTheta=12.0*2.0/sqrt(3.0)*(atan(sqrt(0.6666666*(PosR/Rs)-1.0)));\n            float InnerTheta= kPi / HalfPiTimeInside *iTime * TimeRate ;\n            float PosThetaForInnerCloud = Vec2ToTheta(PosOnDisk.zx, vec2(cos(0.666666*InnerTheta),sin(0.666666*InnerTheta)));\n            float PosTheta            = Vec2ToTheta(PosOnDisk.zx, vec2(cos(-SpiralTheta), sin(-SpiralTheta)));\n\n            // 计算盘温度\n            float DiskTemperature = pow(DiskTemperatureArgument * pow(max(Rs/PosR,0.10),3.0) * max(1.0 - sqrt(InterRadius / PosR), 0.000001), 0.25);\n            // 计算云相对速度\n            vec3  CloudVelocity    = kLightYear / kSpeedOfLight * AngularVelocity * cross(vec3(0., 1., 0.), PosOnDisk);\n            float RelativeVelocity = dot(-DirOnDisk, CloudVelocity);\n            // 计算多普勒因子\n            float Dopler = sqrt((1.0 + RelativeVelocity) / (1.0 - RelativeVelocity));\n            // 总红移量，含多普勒因子和引力红移和\n            float RedShift = Dopler * sqrt(max(1.0 - Rs / PosR, 0.000001)) / sqrt(max(1.0 - Rs / length(CameraPos), 0.000001));\n\n            float Density           = 0.0;\n            float Thick             = 0.0;\n            float VerticalMixFactor = 0.0;\n            float DustColor         = 0.0;\n            \n            float RotPosR=PosR/Rs+0.3*sqrt(3.0)*kSpeedOfLight/kLightYear /3.0/sqrt(3.0)/Rs*TimeRate*iTime;\n            \n            vec4  Color0            = vec4(0.0);\n            \n            Density = Shape(EffectiveRadius, 4.0, 0.9);\n            if (abs(PosY) < 0.5 * Rs * Density)\n            {\n                Thick = 0.5 * Rs * Density * (0.4 + 0.6 * SoftSaturate(GenerateAccretionDiskNoise(vec3(1.5 * PosTheta,RotPosR, 1.0), 1, 3, 80.0))); // 盘厚\n                VerticalMixFactor = max(0.0, (1.0 - abs(PosY) / Thick));\n                Density    *= 0.7 * VerticalMixFactor * Density;\n                Color0      = vec4(GenerateAccretionDiskNoise(vec3(1.0 * RotPosR, 1.0 * PosY / Rs, 0.5 * PosTheta), 3, 6, 80.0)); // 云本体\n                Color0.xyz *= Density * 1.4 * (0.2 + 0.8 * VerticalMixFactor + (0.8 - 0.8 * VerticalMixFactor) *\n                              GenerateAccretionDiskNoise(vec3(RotPosR, 1.5 * PosTheta, PosY / Rs), 1, 3, 80.0));\n                Color0.a   *= (Density); // * (1.0 + VerticalMixFactor);\n            }\n            if (abs(PosY) < 0.5 * Rs * (1.0 - 5.0 * pow(2.0 * (1.0 - EffectiveRadius), 2.0)))\n            {\n                DustColor = max(1.0 - pow(PosY / (0.5 * Rs * max(1.0 - 5.0 * pow(2.0 * (1.0 - EffectiveRadius), 2.0), 0.0001)), 2.0), 0.0) * GenerateAccretionDiskNoise(vec3(1.5 * fract((1.5 *  PosThetaForInnerCloud + kPi / HalfPiTimeInside *iTime*TimeRate) / 2.0 / kPi) * 2.0 * kPi, PosR / Rs, PosY / Rs), 0, 6, 80.0);\n                Color0 += 0.02 * vec4(vec3(DustColor), 0.2 * DustColor) * sqrt(1.0001 - DirOnDisk.y * DirOnDisk.y) * min(1.0, Dopler * Dopler);\n            }\n           \n            Color =  Color0;\n            Color *= 1.0 + 20.0 * exp(-10.0 * (PosR - InterRadius) / (OuterRadius - InterRadius)); // 内侧增加密度\n\n            float BrightWithoutRedshift = 4.5 * DiskTemperature * DiskTemperature * DiskTemperature * DiskTemperature / QuadraticedPeakTemperature;  // 原亮度\n            if (DiskTemperature > 1000.0)\n            {\n                DiskTemperature = max(1000.0, DiskTemperature * RedShift * Dopler * Dopler);\n            }\n\n            DiskTemperature = min(100000.0, DiskTemperature);\n\n            Color.xyz *= BrightWithoutRedshift * min(1.0, 1.8 * (OuterRadius - PosR) / (OuterRadius - InterRadius)) *\n                         KelvinToRgb(DiskTemperature / exp((PosR - InterRadius) / (0.6 * (OuterRadius - InterRadius))));\n            Color.xyz *= min(ShiftMax, RedShift) * min(ShiftMax, Dopler);\n\n            RedShift=min(RedShift,ShiftMax);\n            Color.xyz *= pow((1.0 - (1.0 - min(1., RedShift)) * (PosR - InterRadius) / (OuterRadius - InterRadius)), 9.0);\n            Color.xyz *= min(1.0, 1.0 + 0.5 * ((PosR - InterRadius) / InterRadius + InterRadius / (PosR - InterRadius)) - max(1.0, RedShift));\n\n            Color *= StepLength / Rs;\n        }\n    }\n\n    return BaseColor + Color * (1.0 - BaseColor.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor      = vec4(0., 0., 0., 0.);\n    vec2  FragUv   = fragCoord / iResolution.xy;\n    float Fov      = 0.5;\n    float TimeRate = 30.;  // 本部分在实际使用时又uniform输入，此外所有iTime*TimeRate应替换为游戏内时间。\n\n    float MBlackHole = 1.49e7;                                                                          // 单位是太阳质量 本部分在实际使用时uniform输入\n    float a0         = 0.0;                                                                             // 无量纲自旋系数 本部分在实际使用时uniform输入\n    float Rs         = 2. * MBlackHole * kGravityConstant / kSpeedOfLight / kSpeedOfLight * kSolarMass;  // 单位是米 本部分在实际使用时uniform输入\n\n    float z1       = 1. + pow(1. - a0 * a0, 0.333333333333333) * (pow(1. + a0 * a0, 0.333333333333333) + pow(1. - a0, 0.333333333333333));  // 辅助变量      本部分在实际使用时uniform输入\n    float RmsRatio = (3. + sqrt(3. * a0 * a0 + z1 * z1) - sqrt((3. - z1) * (3. + z1 + 2. * sqrt(3. * a0 * a0 + z1 * z1)))) / 2.;            // 赤道顺行最内稳定圆轨与Rs之比    本部分在实际使用时uniform输入\n    float AccEff   = sqrt(1. - 1. / RmsRatio);                                                                                              // 吸积放能效率,以落到Rms为准 本部分在实际使用时uniform输入\n\n    float mu      = 1.;                                                                            // 吸积物的比荷的倒数,氕为1 本部分在实际使用时uniform输入\n    float dmdtEdd = 6.327 * mu / kSpeedOfLight / kSpeedOfLight * MBlackHole * kSolarMass / AccEff;  // 爱丁顿吸积率 本部分在实际使用时uniform输入\n\n    float dmdt = (2e-6) * dmdtEdd;  // 吸积率 本部分在实际使用时uniform输入\n\n    float diskA = 3. * kGravityConstant * kSolarMass / Rs / Rs / Rs * MBlackHole * dmdt / (8. * kPi * kSigma);  // 吸积盘温度系数 本部分在实际使用时uniform输入\n\n    // 计算峰值温度的四次方,用于自适应亮度。峰值温度出现在49InterRadius/36处\n    float QuadraticedPeakTemperature = diskA * 0.05665278;  //                                                                                          本部分在实际使用时uniform输入\n\n    Rs         = Rs / kLightYear;       // 单位是ly 本部分在实际使用时uniform输入\n    float InterRadius  = 0.7 * RmsRatio * Rs;  // 盘内缘,正常情况下等于最内稳定圆轨\n    float OuterRadius = 12. * Rs;             // 盘外缘 本部分在实际使用时uniform输入\n\n    float shiftMax = 1.25;  // 设定一个蓝移的亮度增加上限,以免亮部过于亮\n\n    vec3 WorldUp            = GetCameraRot(vec4(0., 1., 0., 1.)).xyz;\n    vec4 BlackHoleAPos     = vec4(0.0, 0.0, 5. * Rs, 1.0);             // 黑洞世界位置 本部分在实际使用时没有\n    vec4 BlackHoleADiskNormal = vec4(normalize(vec3(0.2,1.0,0.0)), 1.0);  // 吸积盘世界法向 本部分在实际使用时没有\n    // 以下在相机系\n    vec3  BlackHoleRPos     = GetCamera(BlackHoleAPos).xyz;         //                                                                                     本部分在实际使用时uniform输入\n    vec3  BlackHoleRDiskNormal = GetCameraRot(BlackHoleADiskNormal).xyz;  //                                                                          本部分在实际使用时uniform输入\n    vec3  RayDir            = FragUvToDir(FragUv + 0.5 * vec2(RandomStep(FragUv, fract(iTime * 1.0 + 0.5)), RandomStep(FragUv, fract(iTime * 1.0))) / iResolution.xy, Fov);\n    vec3  RayPos            = vec3(0.0, 0.0, 0.0);\n    \n    vec3  PosToBlackHole           = RayPos - BlackHoleRPos;\n    float DistanceToBlackHole = length(PosToBlackHole);\n    vec3  NormalizedPosToBlackHole      = PosToBlackHole / DistanceToBlackHole;\n    \n    RayDir=normalize(RayDir-NormalizedPosToBlackHole*dot(NormalizedPosToBlackHole,RayDir)*(-sqrt(max(1.0-Rs*CubicInterpolate(max(min(1.0-(0.01*DistanceToBlackHole/Rs-1.0)/4.0,1.0),0.0))/DistanceToBlackHole,0.00000000000000001))+1.0));\n    vec3  LastRayPos;\n    vec3  LastRayDir;\n    float StepLength = 0.;\n    float LastR      = length(PosToBlackHole);\n    float CosTheta;\n    float DeltaPhi;\n    float DeltaPhiRate;\n    float RayStep;\n    bool  flag  = true;\n    int   Count = 0;\n    while (flag == true)\n    {  // 测地raymarching\n\n        PosToBlackHole           = RayPos - BlackHoleRPos;\n        DistanceToBlackHole      = length(PosToBlackHole);\n        NormalizedPosToBlackHole = PosToBlackHole / DistanceToBlackHole;\n\n        if (DistanceToBlackHole > (2.5 * OuterRadius) && DistanceToBlackHole > LastR && Count > 50)\n        {  // 远离黑洞\n            flag   = false;\n            FragUv = DirToFragUv(RayDir);\n        }\n        if (DistanceToBlackHole < 0.1 * Rs)\n        {\n            flag = false;\n        }\n        if (flag == true)\n        {\n            fragColor = DiskColor(fragColor, TimeRate, StepLength, RayPos, LastRayPos, RayDir, LastRayDir, WorldUp, BlackHoleRPos, BlackHoleRDiskNormal, Rs, InterRadius, OuterRadius, diskA, QuadraticedPeakTemperature, shiftMax);  // 吸积盘颜色\n        }\n\n        if (fragColor.a > 0.99)\n        {\n            flag = false;\n        }\n        LastRayPos   = RayPos;\n        LastRayDir   = RayDir;\n        LastR        = DistanceToBlackHole;\n        CosTheta     = length(cross(NormalizedPosToBlackHole, RayDir));                           // 前进方向与切向夹角\n        DeltaPhiRate = -1.0 * CosTheta * CosTheta * CosTheta * (1.5 * Rs / DistanceToBlackHole);  // 单位长度光偏折角\n        if (Count == 0)\n        {\n            RayStep = RandomStep(FragUv, fract(iTime * 1.0));  // 光起步步长抖动\n        }\n        else\n        {\n            RayStep = 1.0;\n        }\n\n        RayStep *= 0.15 + 0.25 * min(max(0.0, 0.5 * (0.5 * DistanceToBlackHole / max(10.0 * Rs, OuterRadius) - 1.0)), 1.0);\n\n        if ((DistanceToBlackHole) >= 2.0 * OuterRadius)\n        {\n            RayStep *= DistanceToBlackHole;\n        }\n        else if ((DistanceToBlackHole) >= 1.0 * OuterRadius)\n        {\n            RayStep *= ((Rs) * (2.0 * OuterRadius - DistanceToBlackHole) +\n                        DistanceToBlackHole * (DistanceToBlackHole - OuterRadius)) / OuterRadius;\n        }\n        else\n        {\n            RayStep *= min(Rs,DistanceToBlackHole);\n        }\n\n        RayPos += RayDir * RayStep;\n        DeltaPhi = RayStep / DistanceToBlackHole * DeltaPhiRate;\n        RayDir     = normalize(RayDir + (DeltaPhi + DeltaPhi * DeltaPhi * DeltaPhi / 3.0) *\n                     cross(cross(RayDir, NormalizedPosToBlackHole), RayDir) / CosTheta);  // 更新方向，里面的（dthe +DeltaPhi^3/3）是tan（dthe）\n        StepLength = RayStep;\n\n        Count++;\n    }\n    // 为了套bloom先逆处理一遍\n    float colorRFactor = 3.0*fragColor.r / (fragColor.g+fragColor.g+fragColor.b);\n    float colorBFactor = 3.0*fragColor.b / (fragColor.g+fragColor.g+fragColor.b);\n    float colorGFactor = 3.0*fragColor.g / (fragColor.g+fragColor.g+fragColor.b);\n\n    float bloomMax = 12.0;\n    fragColor.r    = min(-4.0 * log(1. - pow(fragColor.r, 2.2)), bloomMax * colorRFactor);\n    fragColor.g    = min(-4.0 * log(1. - pow(fragColor.g, 2.2)), bloomMax * colorGFactor);\n    fragColor.b    = min(-4.0 * log(1. - pow(fragColor.b, 2.2)), bloomMax * colorBFactor);\n    fragColor.a    = min(-4.0 * log(1. - pow(fragColor.a, 2.2)), 4.0);\n\n    // TAA\n\n    float blendWeight = 1.0 - pow(0.5, (iTimeDelta) / max(min((0.131 * 36.0 / (TimeRate) * (GetKeplerianAngularVelocity(3. * 0.00000465, 0.00000465)) / (GetKeplerianAngularVelocity(3. * Rs, Rs))), 0.3),\n                                                          0.02));  // 本部分在实际使用时max(min((0.131*36.0/(TimeRate)*(omega(3.*0.00000465,0.00000465))/(omega(3.*Rs,Rs))),0.3),0.02)由uniform输入\n    blendWeight       = (iFrame < 2 || iMouse.z > 0.0) ? 1.0 : blendWeight;\n\n    vec4 previousColor = texelFetch(iChannel3, ivec2(fragCoord), 0);                     // 获取前一帧的颜色\n    fragColor          = (blendWeight)*fragColor + (1.0 - blendWeight) * previousColor;  // 混合当前帧和前一帧\n\n    // FragUv=DirToFragUv();\n\n    // fragColor=texelFetch(iChannel1, ivec2(FragUv*iChannelResolution[1].xy), 0 );\n    // fragColor=vec4(0.1*log(fragColor.r+1.),0.1*log(fragColor.g+1.),0.1*log(fragColor.b+1.),0.1*log(fragColor.a+1.));\n}\n\n//void main()\n//{\n//}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(-float(oversampling)*0.5) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(-float(oversampling)*0.5) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(-float(oversampling)*0.5) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  }
 ]
}